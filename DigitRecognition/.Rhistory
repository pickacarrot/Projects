num_crossover = S - sum(index)
new_population[index == 0] Ôºù lapply(1:num_crossover,
function(k){crossover_child(current_population, rankDF)})
new_generation = function(current_population, lossFunc, p_cross, p_c){
rankDF = rank_population(current_population, method)
S = length(current_population)
new_population = current_population # copy the structure of current generation
index = sample(c(0,1), S, replace = TRUE, prob = c(p_cross, 1-p_cross))
num_crossover = S - sum(index)
for (i in c(1:S)){
if(index[i]==0){
new_population[i] = crossover_child(current_population, rankDF)
}
else
new_population[i] = mutation_child(current_population, rankDF, p_c)
}
return(new_population)
}
new_generation = function(current_population, lossFunc, p_cross, p_c){
rankDF = rank_population(current_population, lossFunc)
S = length(current_population)
new_population = current_population # copy the structure of current generation
index = sample(c(0,1), S, replace = TRUE, prob = c(p_cross, 1-p_cross))
num_crossover = S - sum(index)
for (i in c(1:S)){
if(index[i]==0){
new_population[i] = crossover_child(current_population, rankDF)
}
else
new_population[i] = mutation_child(current_population, rankDF, p_c)
}
return(new_population)
}
new_generation(init_population, MDL, 0.9, 0.05)
rankDF = rank_population(current_population, MDL)
rankDF
crossover_child(current_population, rankDF)
new_population[i] = crossover_child(current_population, rankDF)
new_population[1] = crossover_child(current_population, rankDF)
new_population[1]
new_population = current_population
new_population[1]
new_population = list()
class(new_population)
new_population[1]
new_population = list(new_population,crossover_child(current_population, rankDF))
class(new_population)
new_population[1]
new_population = c(new_population,crossover_child(current_population, rankDF))
new_population[1]
a = list()
a
class(a)
length(a)
crossover_child(current_population, rankDF)
list(crossover_child(current_population, rankDF))
new_population = list(new_population,list(crossover_child(current_population, rankDF)))
new_population
class(new_population)
length(new_population)
new_population[1]
new_population = list() # copy the structure of current generation
new_population = c(new_population,list(crossover_child(current_population, rankDF)))
new_population[1]
class(new_population)
new_population[1]
length(new_population)
new_generation = function(current_population, lossFunc, p_cross, p_c){
rankDF = rank_population(current_population, lossFunc)
S = length(current_population)
new_population = list() # copy the structure of current generation
index = sample(c(0,1), S, replace = TRUE, prob = c(p_cross, 1-p_cross))
for (i in c(1:S)){
if(index[i]==0){
new_population = c(new_population,list(crossover_child(current_population, rankDF)))
}
else
new_population = c(new_population, list(mutation_child(current_population, rankDF, p_c)))
}
return(new_population)
}
new_generation(current_population, MDL, 0.9, 0.05)
new = new_generation(current_population, MDL, 0.9, 0.05)
class(new)
length(new)
new[1]
loss_vec = unlist(lapply(init_population, function(ch){MDL(ch, x,y)}))
loss_vec
find.min(loss_vec)
min(loss_vec)
which(loss_vec = min(loss_vec))
which(loss_vec == min(loss_vec))
population[which(loss_vec == min(loss_vec)]
init_population[which(loss_vec == min(loss_vec)]
which(loss_vec == min(loss_vec)
)
population[which(loss_vec == min(loss_vec))]
init_population[which(loss_vec == min(loss_vec))]
init_population[[which(loss_vec == min(loss_vec))]]
best =init_population[[which(loss_vec == min(loss_vec))]]
MDL(best, x, y)
best_chromosome = function(population, lossFunc){
loss_vec = unlist(lapply(population, function(ch){lossFunc(ch, x,y)}))
best = population[[which(loss_vec == min(loss_vec))]]
return(best)
}
init_p=0.1
init_population = lapply(1:S, function(i){gen_init_chro(len, init_p)})
best_chromosome = function(population, lossFunc){
loss_vec = unlist(lapply(population, function(ch){lossFunc(ch, x,y)}))
min_loss = min(loss_vec)
#best = population[[which(loss_vec == min_loss)]]
return(min_loss)
}
best_generation(x, y, lossFunc, S, p_cross, p_c, N_same){
N=1
init_p=0.1
init_population = lapply(1:S, function(i){gen_init_chro(len, init_p)})
current_population = init_population
new_population = new_generation(current_population, lossFunc, p_cross, p_c)
while(N<N_same){
best_current = best_chromosome(current_population)
best_new = best_chromosome(new_population)
if (best_current==best_new){
N=N+1
}
else
N =1
current_population = new_population
new_population = new_generation(current_population, lossFunc, p_cross, p_c)
}
return(current_population)
}
best_generation(x, y, lossFunc, S, p_cross, p_c, N_same){
N=1
init_p=0.1
init_population = lapply(1:S, function(i){gen_init_chro(len, init_p)})
current_population = init_population
new_population = new_generation(current_population, lossFunc, p_cross, p_c)
while(N<N_same){
best_current = best_chromosome(current_population)
best_new = best_chromosome(new_population)
if (best_current==best_new){
N=N+1
}
else {N =1}
current_population = new_population
new_population = new_generation(current_population, lossFunc, p_cross, p_c)
}
return(current_population)
}
best_generation(x, y, lossFunc, S, p_cross, p_c, N_same){
N=1
init_p=0.1
init_population = lapply(1:S, function(i){gen_init_chro(len, init_p)})
current_population = init_population
new_population = new_generation(current_population, lossFunc, p_cross, p_c)
while(N<N_same){
best_current = best_chromosome(current_population)
best_new = best_chromosome(new_population)
if (best_current==best_new){
N=N+1
}
else {N =1}
current_population = new_population
new_population = new_generation(current_population, lossFunc, p_cross, p_c)
}
return(current_population)
}
current_population = init_population
new_population = new_generation(current_population, lossFunc, p_cross, p_c)
lossFunc=MDL
new_population = new_generation(current_population, lossFunc, p_cross, p_c)
p_c=0.05
new_population = new_generation(current_population, lossFunc, p_cross, p_c)
new_population
N_same = 20
N<N_same
best_current = best_chromosome(current_population)
best_current = best_chromosome(current_population, lossFunc)
best_new = best_chromosome(new_population, lossFunc)
best_current
best_new
best_current==best_new
if (best_current==best_new){
N=N+1
}
else {N =1}
if(best_current==best_new){N=N+1}
else{N =1}
if(best_current==best_new){
N=N+1} else{
N =1}
N
current_population = new_population
new_population = new_generation(current_population, lossFunc, p_cross, p_c)
best_current = best_chromosome(current_population, lossFunc)
best_new = best_chromosome(new_population, lossFunc)
best_current
best_new
new_population = new_generation(current_population, lossFunc, p_cross, p_c)
best_new = best_chromosome(new_population, lossFunc)
best_new
best_generation(x, y, lossFunc, S, p_cross, p_c, N_same){
N=1
init_p=0.1
init_population = lapply(1:S, function(i){gen_init_chro(len, init_p)})
current_population = init_population
new_population = new_generation(current_population, lossFunc, p_cross, p_c)
while(N<N_same){
best_current = best_chromosome(current_population, lossFunc)
best_new = best_chromosome(new_population, lossFunc)
if(best_current==best_new){
N=N+1} else{
N =1}
current_population = new_population
new_population = new_generation(current_population, lossFunc, p_cross, p_c)
}
return(current_population)
}
init_p=0.1
init_population = lapply(1:S, function(i){gen_init_chro(len, init_p)})
current_population = init_population
new_population = new_generation(current_population, lossFunc, p_cross, p_c)
best_current = best_chromosome(current_population, lossFunc)
best_new = best_chromosome(new_population, lossFunc)
best_current
best_new
current_population = new_population
new_population = new_generation(current_population, lossFunc, p_cross, p_c)
best_current = best_chromosome(current_population, lossFunc)
best_new = best_chromosome(new_population, lossFunc)
best_current
best_new
best_generation(x, y, lossFunc, S, p_cross, p_c, N_same){
N=1
init_p=0.1
init_population = lapply(1:S, function(i){gen_init_chro(len, init_p)})
current_population = init_population
new_population = new_generation(current_population, lossFunc, p_cross, p_c)
while(N<N_same){
best_current = best_chromosome(current_population, lossFunc)
best_new = best_chromosome(new_population, lossFunc)
if(best_current==best_new){
N=N+1} else{
N =1}
current_population = new_population
new_population = new_generation(current_population, lossFunc, p_cross, p_c)
}
return(current_population)
}
best_generation = function(x, y, lossFunc, S, p_cross, p_c, N_same){
N=1
init_p=0.1
init_population = lapply(1:S, function(i){gen_init_chro(len, init_p)})
current_population = init_population
new_population = new_generation(current_population, lossFunc, p_cross, p_c)
while(N<N_same){
best_current = best_chromosome(current_population, lossFunc)
best_new = best_chromosome(new_population, lossFunc)
if(best_current==best_new){
N=N+1} else{
N =1}
current_population = new_population
new_population = new_generation(current_population, lossFunc, p_cross, p_c)
}
return(current_population)
}
best_generation(x, y, lossFunc, S, p_cross, p_c, N_same)
end_generation = best_generation(x, y, lossFunc, S, p_cross, p_c, N_same)
best_chromosome = function(population, lossFunc){
loss_vec = unlist(lapply(population, function(ch){lossFunc(ch, x,y)}))
min_loss = min(loss_vec)
best_ch = population[[which(loss_vec == min_loss)]]
return(list(min_loss,best_ch))
}
end_generation
best_chromosome(end_population)
best_chromosome(end_generation)
best_chromosome(end_generation,MDL)
best_chromosome = function(population, lossFunc){
loss_vec = unlist(lapply(population, function(ch){lossFunc(ch, x,y)}))
min_loss = min(loss_vec)
return(min_loss)
}
end_generation
best_chromosome(end_generation)
best_chromosome(end_generation, MDL)
end_rankDF = rank_population(end_generation, MDL)
best_chromosome = function(population, lossFunc){
loss_vec = unlist(lapply(population, function(ch){lossFunc(ch, x,y)}))
min_loss = min(loss_vec)
best_ch = population[[which(loss_vec==min_loss)]]
return(best_ch)
}
loss_best_chromosome = function(population, lossFunc){
loss_vec = unlist(lapply(population, function(ch){lossFunc(ch, x,y)}))
min_loss = min(loss_vec)
return(min_loss)
}
best_chromosome(end_generation, MDL)
best_chromosome = function(population, lossFunc){
loss_vec = unlist(lapply(population, function(ch){lossFunc(ch, x,y)}))
min_loss = min(loss_vec)
best_ch = population[which(loss_vec==min_loss)]
return(best_ch)
}
best_chromosome(end_generation, MDL)
end_chromosome = best_chromosome(end_generation, MDL)
end_chromosome[1]
end_chromosome = best_chromosome(end_generation, MDL)[[1]]
end_chromosome
end_loss = loss_best_chromosome(end_generation, MDL)
end_loss
myplot = function(x, y, chromosome){
y_hat = y_hat_and_n_j(chromosome, y)[[1]]
plot(x,y)
lines(x,y_hat)
}
x
myplot(x, y, end_chromosome)
2^10
2^7
2^8
log(0.1)
log(0.1)*0.5
exp(-1.15)
exp(-1.15*2)
chisq(0)
qchisq(0.95,8)
log(2)
0.25/log(2)
0.25*20/log(2)
ppois(1, 5)
1-ppois(7, 5)
ppois(7,10)
log(5)
findMLE = function(init, N, tol){
alpha0 = init
while (n <N){
alpha1 = sqrt((2.3^2+3.1^2+2.5^2+1.1^2+2*alpha0^2)/4)
if (abs(alpha1-plpha0)<tol{break}
alph0 = alpha1
}
return (alpha1)
}
findMLE = function(init, N, tol){
alpha0 = init
while (n <N){
alpha1 = sqrt((2.3^2+3.1^2+2.5^2+1.1^2+2*alpha0^2)/4)
if (abs(alpha1-plpha0)<tol{
break}
alph0 = alpha1}
return (alpha1)
}
findMLE = function(init, N, tol){
alpha0 = init
while (n <N){
alpha1 = sqrt((2.3^2+3.1^2+2.5^2+1.1^2+2*alpha0^2)/4)
if (abs(alpha1-plpha0)<tol){
break}
alph0 = alpha1}
return (alpha1)
}
findMLE(init = 1, N = 1000, tol = 1e-07)
findMLE = function(init, N, tol){
alpha0 = init
while (n <N){
alpha1 = sqrt((2.3^2+3.1^2+2.5^2+1.1^2+2*alpha0^2)/4)
if (abs(alpha1-alpha0)<tol){
break}
alpha0 = alpha1}
return (alpha1)
}
findMLE(init = 1, N = 1000, tol = 1e-07)
findMLE(init = 1, N = 10000, tol = 1e-09)
findMLE = function(init, N, tol){
n = 1
alpha0 = init
while (n <N){
alpha1 = sqrt((2.3^2+3.1^2+2.5^2+1.1^2+2*alpha0^2)/4)
if (abs(alpha1-alpha0)<tol){
break}
n = n+1
alpha0 = alpha1}
return (list(n,alpha1))
}
findMLE(init = 1, N = 10000, tol = 1e-09)
findMLE(init = 1, N = 1000, tol = 1e-19)
findMLE(init = 1, N = 1000, tol = 1e-20)
?rootSolve
??rootSolve
?root
??root
findMLE = function(init, N, tol){
# the input includes intial value, maximum iterations, and the convergence tolerance
# output the iteration number till covergence and the MLE of alpha
n = 1
theta0 = init
while (n <N){
theta1 = (160*theta0+70)/(197*theta0+144)
if (abs(theta1-theta0)<tol){
break}
n = n+1
theta0 = theta1}
return (list(n,theta1))
}
tol = 1e-7
tol
findMLE(init = 1, N = 1000, tol = 1e-7)
findMLE(init = 1, N = 1000, tol = 1e-20)
2.3^2+3.1^2+2.5^2+1.1^2
Appendix: R code#1findMLE = function(init, N, tol){  # the input includes intial value, maximum iterations, and the convergence tolerance  # output the iteration number till covergence and the MLE of theta  n = 1  theta0 = init  while (n <N){    theta1 = (160*theta0+70)/(197*theta0+144)    if (abs(theta1-theta0)<tol){      break}    n = n+1    theta0 = theta1}  return (list(n,theta1))  }findMLE(init = 1, N = 1000, tol = 1e-20) # it converges after 19 iterations# the MLE of alpha if 0.6380864#3findMLE = function(init, N, tol){  # the input includes intial value, maximum iterations, and the convergence tolerance  # output the iteration number till covergence and the MLE of alpha  n = 1  alpha0 = init  while (n <N){    alpha1 = sqrt((2.3^2+3.1^2+2.5^2+1.1^2+2*alpha0^2)/4)    if (abs(alpha1-alpha0)<tol){      break}    n = n+1    alpha0 = alpha1}  return (list(n,alpha1))  }findMLE(init = 1, N = 1000, tol = 1e-20) # it converges after 54 iterations# the MLE of alpha if 3.343651#4u = runif(5000)#inverse samplex = - log(1-u*(1-1/exp(2)))#hist of the samplehist(x, prob = TRUE, main = "Histogram of the sample")#true density lineX = seq(0,2, 2/5000)true = exp(1)^2/(exp(1)^2-1)*exp(-X)lines(X, true)#estimated density of the sampled = density(x)lines(d, col = "blue")legend("topright", c("estimated density","true density"), col = c("blue", "black"), lty = 1)#5# f(x) by g1(x)n = 5000k = 0      #counter for acceptedj1 = 0      #iterationsy1 = numeric(n)while (k < n) {  u = runif(1)  j1 = j1 + 1  u1 = runif(1)  x = -log(u1)  #random variate from g1  if (1/(1+x^2) > u)  {    k = k + 1    y1[k] = x  }}#number of iterationsj1# it is 8111#density of y1plot(density(y1), xlim = c(0, 5), main = "estimated density of f(x) from g1")# f(x) by g2(x)n = 5000k = 0      #counter for acceptedj2 = 0      #iterationsy2 = numeric(n)while (k < n) {  u = runif(1)  j2 = j2 + 1  u1 = runif(1)  x = tan(u1*pi/2)  #random variate from g2  if (exp(-x) > u) {    k = k + 1    y2[k] = x  }}#number of iterationsj2# it is 12610#density of y2plot(density(y2), xlim = c(0,5), main = "estimated density of f(x) from g2")#compared1 = density(y1)d2 = density(y2)plot(c(0,5), range(d1$y, d2$y), type = "n", xlab = "y", ylab = "Density", main = "density of f(x)")lines(d1, col = "red")lines(d2, col = "blue")x = seq(0, 5, 5/5000)g1 = exp(-x)g2 = 2/(pi*(1+x^2))lines(x, g1, col = "green")lines(x, g2, col = "yellow")legend("topright", c("f(x) from g1","f(x) from g2", "density of g1", "density of g2"),        col = c("red","blue", "green", "yellow"), lty = 1)pi/2# it is 1.570796j2/j1# it is 1.554679#6sample = function(theta){  n = 5000  k = 0      #counter for accepted  j = 0      #iterations  y = numeric(n)  while (k < n) {    u = runif(1)    j = j + 1    i = rbinom(1, 1, prob = 2*gamma(theta)/(2*gamma(theta) + gamma(theta + 1)))    if (i == 1){      x = rgamma(1, theta, 1)    }    else{      x = rgamma(1, theta+0.5, 1)    }    if (sqrt(4+x)/(2+sqrt(x)) > u) {      k = k + 1      y[k] = x    }  }  y}d1 = density(sample(0.5))d2 = density(sample(1))d3 = density(sample(1.5))plot(range(d1$x, d2$x, d3$x), range(d1$y, d2$y, d3$y), type = "n", xlab = "y", ylab = "Density",      main = "estimated density of f(x)")lines(d1, col = "red")lines(d2, col = "blue")lines(d3, col = "green")legend("topright", c("0.5","1", "1.5"), col = c("red","blue", "green"), lty = 1)
# STA243 homework 3# Yuan Tian, Juanjuan Hu# Appendix: R code#1findMLE = function(init, N, tol){  # the input includes intial value, maximum iterations, and the convergence tolerance  # output the iteration number till covergence and the MLE of theta  n = 1  theta0 = init  while (n <N){    theta1 = (160*theta0+70)/(197*theta0+144)    if (abs(theta1-theta0)<tol){      break}    n = n+1    theta0 = theta1}  return (list(n,theta1))  }findMLE(init = 1, N = 1000, tol = 1e-20) # it converges after 19 iterations# the MLE of alpha if 0.6380864#3findMLE = function(init, N, tol){  # the input includes intial value, maximum iterations, and the convergence tolerance  # output the iteration number till covergence and the MLE of alpha  n = 1  alpha0 = init  while (n <N){    alpha1 = sqrt((2.3^2+3.1^2+2.5^2+1.1^2+2*alpha0^2)/4)    if (abs(alpha1-alpha0)<tol){      break}    n = n+1    alpha0 = alpha1}  return (list(n,alpha1))  }findMLE(init = 1, N = 1000, tol = 1e-20) # it converges after 54 iterations# the MLE of alpha if 3.343651#4u = runif(5000)#inverse samplex = - log(1-u*(1-1/exp(2)))#hist of the samplehist(x, prob = TRUE, main = "Histogram of the sample")#true density lineX = seq(0,2, 2/5000)true = exp(1)^2/(exp(1)^2-1)*exp(-X)lines(X, true)#estimated density of the sampled = density(x)lines(d, col = "blue")legend("topright", c("estimated density","true density"), col = c("blue", "black"), lty = 1)#5# f(x) by g1(x)n = 5000k = 0      #counter for acceptedj1 = 0      #iterationsy1 = numeric(n)while (k < n) {  u = runif(1)  j1 = j1 + 1  u1 = runif(1)  x = -log(u1)  #random variate from g1  if (1/(1+x^2) > u)  {    k = k + 1    y1[k] = x  }}#number of iterationsj1# it is 8111#density of y1plot(density(y1), xlim = c(0, 5), main = "estimated density of f(x) from g1")# f(x) by g2(x)n = 5000k = 0      #counter for acceptedj2 = 0      #iterationsy2 = numeric(n)while (k < n) {  u = runif(1)  j2 = j2 + 1  u1 = runif(1)  x = tan(u1*pi/2)  #random variate from g2  if (exp(-x) > u) {    k = k + 1    y2[k] = x  }}#number of iterationsj2# it is 12610#density of y2plot(density(y2), xlim = c(0,5), main = "estimated density of f(x) from g2")#compared1 = density(y1)d2 = density(y2)plot(c(0,5), range(d1$y, d2$y), type = "n", xlab = "y", ylab = "Density", main = "density of f(x)")lines(d1, col = "red")lines(d2, col = "blue")x = seq(0, 5, 5/5000)g1 = exp(-x)g2 = 2/(pi*(1+x^2))lines(x, g1, col = "green")lines(x, g2, col = "yellow")legend("topright", c("f(x) from g1","f(x) from g2", "density of g1", "density of g2"),        col = c("red","blue", "green", "yellow"), lty = 1)pi/2# it is 1.570796j2/j1# it is 1.554679#6sample = function(theta){  n = 5000  k = 0      #counter for accepted  j = 0      #iterations  y = numeric(n)  while (k < n) {    u = runif(1)    j = j + 1    i = rbinom(1, 1, prob = 2*gamma(theta)/(2*gamma(theta) + gamma(theta + 1)))    if (i == 1){      x = rgamma(1, theta, 1)    }    else{      x = rgamma(1, theta+0.5, 1)    }    if (sqrt(4+x)/(2+sqrt(x)) > u) {      k = k + 1      y[k] = x    }  }  y}d1 = density(sample(0.5))d2 = density(sample(1))d3 = density(sample(1.5))plot(range(d1$x, d2$x, d3$x), range(d1$y, d2$y, d3$y), type = "n", xlab = "y", ylab = "Density",      main = "estimated density of f(x)")lines(d1, col = "red")lines(d2, col = "blue")lines(d3, col = "green")legend("topright", c("0.5","1", "1.5"), col = c("red","blue", "green"), lty = 1)
findMLE = function(init, N, tol){  # the input includes intial value, maximum iterations, and the convergence tolerance  # output the iteration number till covergence and the MLE of theta  n = 1  theta0 = init  while (n <N){    theta1 = (160*theta0+70)/(197*theta0+144)    if (abs(theta1-theta0)<tol){      break}    n = n+1    theta0 = theta1}  return (list(n,theta1))  }findMLE(init = 1, N = 1000, tol = 1e-20) # it converges after 19 iterations# the MLE of alpha if 0.6380864#3findMLE = function(init, N, tol){  # the input includes intial value, maximum iterations, and the convergence tolerance  # output the iteration number till covergence and the MLE of alpha  n = 1  alpha0 = init  while (n <N){    alpha1 = sqrt((2.3^2+3.1^2+2.5^2+1.1^2+2*alpha0^2)/4)    if (abs(alpha1-alpha0)<tol){      break}    n = n+1    alpha0 = alpha1}  return (list(n,alpha1))  }findMLE(init = 1, N = 1000, tol = 1e-20) # it converges after 54 iterations# the MLE of alpha if 3.343651#4u = runif(5000)#inverse samplex = - log(1-u*(1-1/exp(2)))#hist of the samplehist(x, prob = TRUE, main = "Histogram of the sample")#true density lineX = seq(0,2, 2/5000)true = exp(1)^2/(exp(1)^2-1)*exp(-X)lines(X, true)#estimated density of the sampled = density(x)lines(d, col = "blue")legend("topright", c("estimated density","true density"), col = c("blue", "black"), lty = 1)#5# f(x) by g1(x)n = 5000k = 0      #counter for acceptedj1 = 0      #iterationsy1 = numeric(n)while (k < n) {  u = runif(1)  j1 = j1 + 1  u1 = runif(1)  x = -log(u1)  #random variate from g1  if (1/(1+x^2) > u)  {    k = k + 1    y1[k] = x  }}#number of iterationsj1# it is 8111#density of y1plot(density(y1), xlim = c(0, 5), main = "estimated density of f(x) from g1")# f(x) by g2(x)n = 5000k = 0      #counter for acceptedj2 = 0      #iterationsy2 = numeric(n)while (k < n) {  u = runif(1)  j2 = j2 + 1  u1 = runif(1)  x = tan(u1*pi/2)  #random variate from g2  if (exp(-x) > u) {    k = k + 1    y2[k] = x  }}#number of iterationsj2# it is 12610#density of y2plot(density(y2), xlim = c(0,5), main = "estimated density of f(x) from g2")#compared1 = density(y1)d2 = density(y2)plot(c(0,5), range(d1$y, d2$y), type = "n", xlab = "y", ylab = "Density", main = "density of f(x)")lines(d1, col = "red")lines(d2, col = "blue")x = seq(0, 5, 5/5000)g1 = exp(-x)g2 = 2/(pi*(1+x^2))lines(x, g1, col = "green")lines(x, g2, col = "yellow")legend("topright", c("f(x) from g1","f(x) from g2", "density of g1", "density of g2"),        col = c("red","blue", "green", "yellow"), lty = 1)pi/2# it is 1.570796j2/j1# it is 1.554679#6sample = function(theta){  n = 5000  k = 0      #counter for accepted  j = 0      #iterations  y = numeric(n)  while (k < n) {    u = runif(1)    j = j + 1    i = rbinom(1, 1, prob = 2*gamma(theta)/(2*gamma(theta) + gamma(theta + 1)))    if (i == 1){      x = rgamma(1, theta, 1)    }    else{      x = rgamma(1, theta+0.5, 1)    }    if (sqrt(4+x)/(2+sqrt(x)) > u) {      k = k + 1      y[k] = x    }  }  y}d1 = density(sample(0.5))d2 = density(sample(1))d3 = density(sample(1.5))plot(range(d1$x, d2$x, d3$x), range(d1$y, d2$y, d3$y), type = "n", xlab = "y", ylab = "Density",      main = "estimated density of f(x)")lines(d1, col = "red")lines(d2, col = "blue")lines(d3, col = "green")legend("topright", c("0.5","1", "1.5"), col = c("red","blue", "green"), lty = 1)
findMLE = function(init, N, tol){  # the input includes intial value, maximum iterations, and the convergence tolerance  # output the iteration number till covergence and the MLE of theta  n = 1  theta0 = init  while (n <N){    theta1 = (160*theta0+70)/(197*theta0+144)    if (abs(theta1-theta0)<tol){      break}    n = n+1    theta0 = theta1}  return (list(n,theta1))  }findMLE(init = 1, N = 1000, tol = 1e-20)
findMLE = function(init, N, tol){  # the input includes intial value, maximum iterations, and the convergence tolerance  # output the iteration number till covergence and the MLE of theta  n = 1  theta0 = init  while (n <N){    theta1 = (160*theta0+70)/(197*theta0+144)    if (abs(theta1-theta0)<tol){      break}    n = n+1    theta0 = theta1}  return (list(n,theta1))  }
findMLE = function(init, N, tol){
# the input includes intial value, maximum iterations, and the convergence tolerance
# output the iteration number till covergence and the MLE of theta
n = 1
theta0 = init
while (n <N){
theta1 = (160*theta0+70)/(197*theta0+144)
if (abs(theta1-theta0)<tol){
break}
n = n+1
theta0 = theta1}
return (list(n,theta1))
}
findMLE(init = 1, N = 1000, tol = 1e-20)
findMLE = function(init, N, tol){  # the input includes intial value, maximum iterations, and the convergence tolerance  # output the iteration number till covergence and the MLE of theta  n = 1  theta0 = init  while (n <N){    theta1 = (160*theta0+70)/(197*theta0+144)    if (abs(theta1-theta0)<tol){      break}    n = n+1    theta0 = theta1}  return (list(n,theta1))  }
findMLE = function(init, N, tol){  # the input includes intial value, maximum iterations, and the convergence tolerance  # output the iteration number till covergence and the MLE of theta  n = 1  theta0 = init  while (n <N){    theta1 = (160*theta0+70)/(197*theta0+144)    if (abs(theta1-theta0)<tol){      break}    n = n+1    theta0 = theta1}  return (list(n,theta1))}
findMLE = function(init, N, tol){  # the input includes intial value, maximum iterations, and the convergence tolerance  # output the iteration number till covergence and the MLE of theta  n = 1  theta0 = init  while (n <N){    theta1 = (160*theta0+70)/(197*theta0+144)    if (abs(theta1-theta0)<tol){      break}    n = n+1    theta0 = theta1}  return (list(n,theta1))  }
0.15-0.3734
0.15+0.3734
sqrt(28.02/8)
sqrt(28.02/8)*1.4*sqrt(10)
sqrt(28.02/8)*1.4*sqrt(8)
(1/sqrt(28.02/8))*1.4*sqrt(8)
8*1.4/sqrt(28.02/8)
8*1.4/sqrt(28.02)
sqrt(8)*1.4/sqrt(28.02/7)
28.02/7
qt(0,16)
pt(0,16)
pt(8/3,16)
pt(8/3,16)-1
theta1 = 1.5
theta2 = 2
z0 = sqrt(theta2/theta1)
z0
mean_inv_z = sqrt(theta1/theta2)+1/(2*theta2)
mean_inv_z
sampling_imha = function(theta1, theta2, alpha, beta, z0, iter = 1000){
z_c = rep(z0, iter)
for (i in 2:length(z_c)){
y = rgamma(1, alpha, beta)
u = runif(1)
r = min(f(y, theta1, theta2)*dgamma(z_c[i-1],alpha, beta)
/(f(z_c[i-1],theta1, theta2)*dgamma(y, alpha, beta)),1)
z_c[i]=ifelse(u>r, z_c[i-1], y)}
return (z_c)
}
mean_inv_z = sqrt(theta1/theta2)+1/(2*theta2)
mean_z
mean_z = sqrt(theta2/theta1) #initial point
z0=1
result = NULL
for (alpha in alpha_c){
for (beta in beta_c){
z_hat = mean(sampling_imha(1.5, 2, alpha, beta, z0, 1000))
inv_z_hat = mean(1/sampling_imha(1.5, 2, alpha, beta, z0, 1000))
diff_z = mean_z-z_hat
diff_inv_z = mean_inv_z-inv_z_hat
row = c(alpha, beta, z_hat, inv_z_hat, diff_z, diff_inv_z)
result = rbind(result, row)
}
}
result_df = data.frame(result)
names(result_df) = c("alpha","beta","mean_z","mean_inv_z","diff_z", "diff_inv_z")
z0=1
result = NULL
alpha_c = c(2:5)
beta_c = c(2:5)
for (alpha in alpha_c){
for (beta in beta_c){
z_hat = mean(sampling_imha(1.5, 2, alpha, beta, z0, 1000))
inv_z_hat = mean(1/sampling_imha(1.5, 2, alpha, beta, z0, 1000))
diff_z = mean_z-z_hat
diff_inv_z = mean_inv_z-inv_z_hat
row = c(alpha, beta, z_hat, inv_z_hat, diff_z, diff_inv_z)
result = rbind(result, row)
}
}
f = function(z, theta1, theta2){
(1/sqrt(2*pi))*z^(-1.5)*exp(-theta1*z-theta2/z+2*sqrt(theta1*theta2)+log(sqrt(2*theta2)))
}
for (alpha in alpha_c){
for (beta in beta_c){
z_hat = mean(sampling_imha(1.5, 2, alpha, beta, z0, 1000))
inv_z_hat = mean(1/sampling_imha(1.5, 2, alpha, beta, z0, 1000))
diff_z = mean_z-z_hat
diff_inv_z = mean_inv_z-inv_z_hat
row = c(alpha, beta, z_hat, inv_z_hat, diff_z, diff_inv_z)
result = rbind(result, row)
}
}
result_df = data.frame(result)
names(result_df) = c("alpha","beta","mean_z","mean_inv_z","diff_z", "diff_inv_z")
result_df
source('~/Desktop/prob6.R')
